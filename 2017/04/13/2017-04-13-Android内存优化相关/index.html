<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,分享,Blog,内存优化," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="Android内存优化相关Java内存分配策略概述  虚拟机栈（Stack）存放基本数据类型和局部变量引用，但是对象本身不存放在栈中，而是存放在堆中。当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。当方法执行完毕后，这个">
<meta name="keywords" content="Android,分享,Blog,内存优化">
<meta property="og:type" content="article">
<meta property="og:title" content="Android内存优化相关">
<meta property="og:url" content="http://yoursite.com/2017/04/13/2017-04-13-Android内存优化相关/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="Android内存优化相关Java内存分配策略概述  虚拟机栈（Stack）存放基本数据类型和局部变量引用，但是对象本身不存放在栈中，而是存放在堆中。当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。当方法执行完毕后，这个">
<meta property="og:image" content="https://raw.githubusercontent.com/android9527/android9527.github.io/master/src/memory/images/memory.jpeg">
<meta property="og:updated_time" content="2017-06-22T09:16:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android内存优化相关">
<meta name="twitter:description" content="Android内存优化相关Java内存分配策略概述  虚拟机栈（Stack）存放基本数据类型和局部变量引用，但是对象本身不存放在栈中，而是存放在堆中。当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。当方法执行完毕后，这个">
<meta name="twitter:image" content="https://raw.githubusercontent.com/android9527/android9527.github.io/master/src/memory/images/memory.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/13/2017-04-13-Android内存优化相关/"/>





  <title>Android内存优化相关 | 个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/2017-04-13-Android内存优化相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="android9527">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android内存优化相关</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T00:00:00+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Android内存优化相关"><a href="#Android内存优化相关" class="headerlink" title="Android内存优化相关"></a>Android内存优化相关</h2><h3 id="Java内存分配策略概述"><a href="#Java内存分配策略概述" class="headerlink" title="Java内存分配策略概述"></a>Java内存分配策略概述</h3><p><img src="https://raw.githubusercontent.com/android9527/android9527.github.io/master/src/memory/images/memory.jpeg" alt="Overdraw"></p>
<ul>
<li><p>虚拟机栈（Stack）<br>存放基本数据类型和局部变量引用，但是对象本身不存放在栈中，而是存放在堆中。<br>当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。当方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。<br>Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError。<br>Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
</li>
<li><p>堆（Heap）<br>在堆上分配内存的过程称作内存动态分配过程。在Java中堆用于存放由new创建的对象和数组。堆中分配的内存，由java虚拟机自动垃圾回收器（GC）来管理(可见我们要进行的内存优化主要就是对堆内存进行优化)。堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存。</p>
</li>
<li><p>方法区（Method Area）<br>方法区也是线程共享的区域，用于存储已经被虚拟机加载的类信息，常量，静态变量和即时编译器（JIT）编译后的代码等数据。</p>
</li>
<li><p>运行时常量池（Runtime Constant Pool）<br>是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中。</p>
</li>
</ul>
<h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><ol>
<li><p>垃圾对象的判定</p>
<p>Java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，判定对象是否为垃圾对象有如下算法：</p>
<ul>
<li><p>引用计数算法</p>
<p>  给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1，任何时刻计数器都为0的对象就是不可能再被使用的。<br>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的选择，当Java语言并没有选择这种算法来进行垃圾回收，主要原因是它很难解决对象之间的相互循环引用问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">    public class Main &#123;</div><div class="line">        public static void main(String[] args) &#123;</div><div class="line">            MyObject object1 = new MyObject();</div><div class="line">            MyObject object2 = new MyObject();</div><div class="line">            object1.object = object2;</div><div class="line">            object2.object = object1;</div><div class="line">            object1 = null;</div><div class="line">            object2 = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    class MyObject&#123;</div><div class="line">        public Object object = null;</div><div class="line">    &#125;</div><div class="line">    ```	</div><div class="line">    - 根搜索算法</div><div class="line">		</div><div class="line">        Java和C#中都是采用根搜索算法来判定对象是否存活的。这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。在Java语言里，可作为GC Roots的对象包括下面几种：</div><div class="line">1、栈（栈帧中的本地变量表）中引用的对象。</div><div class="line">2、方法区中的静态成员。</div><div class="line">3、方法区中的常量引用的对象</div><div class="line">4、本地方法栈中JNI（一般说的Native方法）引用的对象。</div><div class="line"></div><div class="line"> 1. 垃圾对象回收</div><div class="line"></div><div class="line">	- 标记-清除</div><div class="line"></div><div class="line">		该算法有如下缺点：</div><div class="line">（1）标记和清除过程的效率都不高。</div><div class="line">（2）标记清除后会产生大量不连续的内存碎片，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</div><div class="line">![Overdraw](https://raw.githubusercontent.com/android9527/android9527.github.io/master/src/memory/images/mark_sweep.jpg)</div><div class="line">	- 复制算法</div><div class="line">![Overdraw](https://raw.githubusercontent.com/android9527/android9527.github.io/master/src/memory/images/copying.jpg)</div><div class="line">	- 标记-整理</div><div class="line">![Overdraw](https://raw.githubusercontent.com/android9527/android9527.github.io/master/src/memory/images/mark_compact.jpg)</div><div class="line">	- 分代回收算法</div><div class="line"></div><div class="line">### Android的内存区域</div><div class="line"></div><div class="line"> 1. Dalvik Heap，这部分的内存区域是由Dalvik虚拟机管理，通过Java中 new 关键字来申请一块新内存。这块区域的内存是由GC直接管理，能够自动回收内存。这块内存的大小会受到系统限制，当内存超过APP最大可用内存时会OOM</div><div class="line"></div><div class="line"> 2. Native Heap，这部分内存区域是在C++中申请的，它不受限于APP的最大可用内存限制，而只是受限于设备的物理可用内存限制。它的缺点在于没有自动回收机制，只能通过C++语法来释放申请的内存</div><div class="line"></div><div class="line"> 3. Ashmem（Android匿名共享内存），这部分内存类似于Native内存区，但是它是受Android系统底层管理的。</div><div class="line"></div><div class="line">Android Dalvik Heap与原生Java一样，将堆的内存空间分为三个区域，Young Generation，Old Generation， Permanent Generation。</div><div class="line">最近分配的对象会存放在Young Generation区域，对象在某个时机触发GC回收垃圾，而没有回收的就根据不同规则，有可能被移动到Old Generation，最后积累一定时间再移动到Permanent Generation区域。系统会根据不同的内存数据类型分别采用不同的回收机制。每一个Generation的内存区域都有固定的大小。执行GC占用的时间和它发生在哪一个Generation的内存区域有关，Young Generation中的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。同时GC的执行时间也和当前Generation中的对象数量有关，数量越多，执行时间越长。</div><div class="line">GC时会导致线程暂停，导致卡顿，在ART中对GC过程做了优化，据说内存分配的效率提高了10倍，GC的效率提高了2-3倍，不过主要还是优化中断和阻塞的时间，频繁的GC还是会导致卡顿。</div><div class="line"></div><div class="line">### Android App为什么会OOM呢？</div><div class="line">其实就是申请的内存超过了Dalvik Heap的最大值。于是也诞生了一些比较”黑科技”的内存优化方案，比如将耗内存的操作放到Native层，或者使用分进程的方式突破每个进程的Dalvik Heap内存限制。</div><div class="line"></div><div class="line">### 自身内存占用监控</div><div class="line"></div><div class="line">对于onLowMemory()与onTrimMemory(int)等是针对整个系统而言的。</div><div class="line">通过Runtime.totalMemory-freeMemory即为当前应用使用的内存。</div><div class="line">Runtime.getRuntime().maxMemory(); </div><div class="line">Runtime.getRuntime().totalMemory(); Runtime.getRuntime().freeMemory();</div><div class="line"></div><div class="line">### 避免内存泄漏</div><div class="line">内存泄漏是指应用不再使用的内存对象，但垃圾回收时没有辨认出来，不能及时回收，一直保留在内存中长期占用一定的空间不能释放。</div><div class="line"></div><div class="line">#### 内存泄露的危害： </div><div class="line"></div><div class="line"> - 过多的内存泄露最终会导致内存溢出（OOM）</div><div class="line"> - 内存泄露导致可用内存不足，会触发频繁GC，不管是Android2.2以前的单线程GC还是现在的CMS和G1，都有一部分的操作会导致用户线程停止（就是所谓的Stop the world），从而导致UI卡顿。</div><div class="line"></div><div class="line">#### 常见内存泄漏场景</div><div class="line"></div><div class="line"> 1. 及时关闭资源性对象</div><div class="line">Cursor File往往都使用了一些缓冲，在不使用时，应该及时关闭，以便它们的缓存数据能够及时回收。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Cursor cursor = null;<br>try{</p>
<pre><code>cursor = mContext.getContentResolver().query(uri,null,null,null,null);
if (cursor != null) {
    // 处理数据
}
</code></pre><p>} catch (Exception e){</p>
<pre><code>e.printStatckTrace();
</code></pre><p>} finally {</p>
<pre><code>if (cursor != null){
    cursor.close();
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 注册对象未注销</div><div class="line">广播接收器、注册观察者等</div><div class="line"></div><div class="line">3. 单例Context、static变量等</div></pre></td></tr></table></figure>
<p>private static Resources mResources;<br>@Override<br>protected void onCreate(Bundle state) {</p>
<pre><code>super.onCreate(state);
if (mResources == null) {
    mResources = this.getResources();
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> 4. Handler，AsyncTAsk，TimeTask等内部类</div><div class="line">当Activity退出时，消息队列中还有未处理的消息或者正在处理的消息，并且消息队列中Message持有Handler的实例，handler持有Activity的引用，导致Activity无法被回收。</div><div class="line"></div><div class="line">	需要修改两个地方</div><div class="line">	</div><div class="line">	1）使用静态Handler内部类，如果你需要在Handler子类中调用外部类的方法，可以让Handler持有一个外部类的WeakReference对Handler持有的对象使用弱引用，这样在回收时，也可以回收Handler持有的对象。</div><div class="line"></div><div class="line">	2）在Activity的onDestory时，应该移除消息队列中的消息，避免Looper线程的消息队列中有待处理的消息。asyncTask.cancel()。</div></pre></td></tr></table></figure>
<p>public class WeakRefHandler extends Handler<br>{</p>
<pre><code>WeakReference&lt;Context&gt; mWeakContext; 
public WeakRefHandler(Context context)
{
    mWeakContext = newWeakReference&lt;Context&gt;(context);
}
@Override
public void handleMessage(Message msg)
{
    if((mWeakContext.get() instanceofActivity )&amp;&amp; ((Activity)mWeakContext.get()).isFinishing())
            return ;
    if(mWeakContext==null){
        return ;
    }
    super.handleMessage(msg);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. 集合中的对象没有清理造成的内存泄漏，特别是静态集合</div><div class="line"></div><div class="line">6. SensorManager等系统服务</div><div class="line"></div><div class="line">   系统服务可以通过Context.getSystemService 获取。通过Context.getSystemService()可以获取系统服务。这些服务工作在各自的进程中，帮助应用处理后台任务，处理硬件交互。部分服务使用时需要注册监听器，会导致服务持有了Context的引用，如果在Activity销毁的时候没有注销这些监听器，会导致内存泄漏。</div></pre></td></tr></table></figure>
<p>void registerListener() {</p>
<pre><code>       SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
       Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);
       sensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_FASTEST);
} 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> 7. Bitmap及时调用recycle()</div><div class="line"></div><div class="line">	在不使用Bitmap对象时，需要调用recycle()释放内存，然后将它设置为null。</div><div class="line"></div><div class="line">#### 内存泄漏监控</div><div class="line"></div><div class="line">LeakCanary是一个检测内存的开源类库，实际上就是在本机上自动做了Heap Dump，然后分析生成的hprof文件，展示结果。</div><div class="line"></div><div class="line"> - 实现监控</div><div class="line">导入SDK，builder.gradle文件中加入相关引用</div><div class="line">LeakCanary对应用的性能有一定的影响，特别是Heap Dump操作会消耗更多的系统资源，并且会引起卡顿现象。</div><div class="line">配置还releaseCompile和testCompile的依赖，就不需要担心对正式版本性能产生影响。</div><div class="line"></div><div class="line">`LeakCanary.install()`会安装一个Leaks的APK，返回一个预定义的RefWatcher，同时也启用一个`ActivityRefWatvher`，用于自动监控`Activity.onDestory()`之后泄漏的对象。其原理是设置`Application的ActivityLifecycleCallbacks`方法监控所有Activity的生命周期回调。</div><div class="line"></div><div class="line">默认情况下，只对Activity进行了检测。如果想要监控Fragment实例或者其他自定义的组件，可以在`Fragment.onDestory`方法，或者自定义组件的周期结束回调中加入如下实现：`Application.getRefWatcher().watch(this);`</div><div class="line"></div><div class="line">也可以监控BroadcastReceiver，Service等其他有生命周期的对象等</div><div class="line"></div><div class="line"> - 自定义处理结果</div><div class="line">仅仅依靠默认的监控处理方式，在实际的开发和测试过程中体验不是很好，必须以来安装的Leaks应用，并且不好定制化，因此实现自定义的监控结果处理就很有必要。</div><div class="line">首先继承DisplayLeakService实现一个自定义的监控处理Service</div></pre></td></tr></table></figure>
<p>public class LeakCanaryService extends DisplayLeakService {</p>
<pre><code>@Override
protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
    super.afterDefaultHandling(heapDump, result, leakInfo);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> - 重写afterDefaultHanding方法</div><div class="line">heapDump：堆内存文件，可以拿到完成的hprof文件，使用MAT分析等。</div><div class="line">result：监控到内存的状态，如是否泄漏等。</div><div class="line">leakInfo：leak trace详细信息，除了内存泄漏对象，还有设备信息等。</div><div class="line">然后在install时，使用自定义的LeakCanaryService，如下：</div></pre></td></tr></table></figure>
<p>RefWatcher watcher = LeakCanary.refWatcher(this).listenerServiceClass(LeakCanaryService.class).buildAndInstall();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    就可以实现自己的处理方式，如丰富提示信息、把数据保存到本地、上传到服务器分析等。</div><div class="line"></div><div class="line"></div><div class="line">### 优化内存空间</div><div class="line"></div><div class="line"> 1. 序列化 Serizable Parcelable</div><div class="line">Serializable 序列化时会调用ObjectOutputStream.writeObject 反序列化会调用ObjectInputStream.readObject()引用了大量反射机制，导致GC频繁触发。</div><div class="line">自己实现序列化与反序列化过程需要重写writeObject()和readObject()</div><div class="line"></div><div class="line"> 2. 避免AutoBoxing</div></pre></td></tr></table></figure>
<p>Integer num = 0;<br>for(int i = 0; i &lt; 100; i ++){</p>
<pre><code>num += i;    
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">基础整型int占用4个字节，而Integer对象有16字节。</div><div class="line"></div><div class="line">3. Adapter进行优化</div><div class="line"></div><div class="line">   复用convertView。</div><div class="line">   当快速滑动列表时（SCROLL_STATE_FLING），item中的图片或获取需要消耗资源的view，可以不显示出来；而处于停止滚动状 态（SCROLL_STATE_IDLE）则将那些view显示出来。</div><div class="line"></div><div class="line">4. 少用静态变量</div><div class="line"></div><div class="line">静态变量属于全局变量，不会被GC回收，它们会一直占用内存。</div><div class="line"></div><div class="line">5. 内存复用</div><div class="line">   </div><div class="line">   1). 有效利用系统自带的资源</div><div class="line">重用系统资源：</div><div class="line"></div><div class="line"> - 利用系统定义的id</div></pre></td></tr></table></figure>
<p>android:id=”@android:id/list”  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 利用系统的图片资源</div><div class="line"></div><div class="line">- 利用系统的字符串资源</div><div class="line"></div><div class="line">- 利用系统的Style</div><div class="line"></div><div class="line">- 利用系统的颜色定义</div><div class="line"></div><div class="line">  2) 选用对象池</div><div class="line">  对象池：如果某个对象在创建时，需要较大的资源开销，那么可以将其放入对象池，即将对象保存起来，下次需要时直接取出使用，而不用再次创建对象。当然，维护对象池也需要一定开销，故要衡量。</div></pre></td></tr></table></figure>
<p>Message.obtain()<br>Handler.obtainMessage()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">使用对象池需要需要注意几点：</div><div class="line">将对象放回池中，注意初始化对象的数据，防止存在脏数据</div><div class="line">合理控制池的增长，避免过大，导致很多对象处于闲置状态</div><div class="line">3）线程池：将线程对象放在池中供反复使用，减少反复创建线程的开销。</div><div class="line">线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失</div><div class="line"></div><div class="line"> 6. 单线程模型中，使用非线程安全的类，如：StringBuilder，ArrayList等。</div><div class="line"></div><div class="line"> 7. ViewPager限制加载数量</div><div class="line">ViewPager同时缓存page数如果过多，那么第一次显示时，ViewPager所初始化的pager就会很多，这样pager累积渲染耗时就会增多，看起来就卡。</div><div class="line"></div><div class="line"> 8. for循环</div></pre></td></tr></table></figure>
<p>for(int i = 0; i &lt; getCount(); i ++){</p>
<pre><code>try{        
}catch(){
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    - getCount()方法提取</div><div class="line">    - 避免循环内部创建临时变量</div><div class="line">    - 避免循环内部try&#123;&#125;catch()</div><div class="line"></div><div class="line"> 9. 使用注解替代枚举</div><div class="line">android.support.annotation.IntDef，StringDef</div></pre></td></tr></table></figure>
<pre><code>//先定义 常量
public static final int SUNDAY = 0;
public static final int MONDAY = 1;
public static final int TUESDAY = 2;
public static final int WEDNESDAY = 3;
public static final int THURSDAY = 4;
public static final int FRIDAY = 5;
public static final int SATURDAY = 6;
@IntDef({SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY})
@Retention(RetentionPolicy.SOURCE)
public @interface WeekDays {
}
@WeekDays
private int currentDay = SUNDAY;
@WeekDays
public int getCurrentDay() {
    return currentDay;
}
public void setCurrentDay(@WeekDays int currentDay) {
    this.currentDay = currentDay;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> 10. 减少父类声明</div><div class="line">减少List list = new ArrayList();</div><div class="line">如果事先知道集合大小，则可以在构造方法中设置初始大小。</div><div class="line"></div><div class="line"> 11. 更优的数据结构</div><div class="line">ArrayMap及SparseArray是Android的系统API，用于在一定情况下取代HashMap而达到节省内存的目的，对于key为int的HashMap尽量使用SparceArray替代，大概可以省30%的内存，而对于其他类型，ArrayMap对内存的节省实际并不明显，10%左右，但是数据量在千级以上时，查找速度可能会变慢。</div><div class="line">　</div><div class="line"> 12. 谨慎使用多进程</div><div class="line">现在很多App都不是单进程，为了保活，或者提高稳定性都会进行一些进程拆分，通常我们在Application的onCreate方法中会做很多初始化操作,但是多进程会导致Application初始化多次，为了避免不必要的初始化，建议按照进程(通过判断当前进程名)对应初始化。</div><div class="line">Android应用可以支持开启多个进程。 通常的做法是这样</div></pre></td></tr></table></figure>
<p><service android:name=".PushService" android:process=":remote"></service></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<p>public class MyApplication extends Application {</p>
<pre><code>private static final String LOGTAG = &quot;MyApplication&quot;;
@Override
public void onCreate() {
    super.onCreate();
    String currentProcessName = getCurrentProcessName();
    if (getPackageName().equals(currentProcessName)) {
        //init for default process
    } else if (currentProcessName.endsWith(&quot;:remote&quot;)) {
        //init for netowrk process
    }
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> 13. 合理使用StringBuffer,StringBuilder,String</div><div class="line">在简单的字符串拼接中，String的效率是最高的，例如String s = “hello” + “world”; </div><div class="line">如果你的字符串是来自另外的String对象的话，速度就没那么快了，例如： </div><div class="line">　　　　String str2 = “This is”; </div><div class="line">　　　　String str3 = “ a ”; </div><div class="line">　　　　String str4 = “ test”; </div><div class="line">　　　　String str1 = str2 +str3 + str4; </div><div class="line">这里就要求使用StringBuilder了。</div><div class="line">　　</div><div class="line"> 14. 珍惜Services资源</div><div class="line">如果你的应用需要在后台使用service，除非它被触发并执行一个任务，否则其他时候Service都应该是停止状态。另外需要注意当这个service完成任务之后因为停止service失败而引起的内存泄漏。 当你启动一个Service，系统会倾向为了保留这个Service而一直保留Service所在的进程。IntentService。</div><div class="line"></div><div class="line"> 15. 减少bitmap占用的内存</div><div class="line">    BitmapFactory在解码图片时，可以带一个Options，有一些比较有用的功能，比如：</div><div class="line">    - inSampleSize</div><div class="line"></div><div class="line">	如果采样率为 2，那么读出来的图片只有原始图片的 1/4 大小，</div></pre></td></tr></table></figure>
<p>BitmapFactory.Options options = new Options();<br>options.inSampleSize = 2;<br>Bitmap bitmap = BitmapFactory.decodeResource(getResources(), resId, options);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">宽高降为1 / 2，像素数降为1 / 4</div><div class="line">	- inJustDecodeBounds</div><div class="line"></div><div class="line">	有时如果只是为了获取图片的大小就可以用这个，而不必直接加载整张图片。</div><div class="line">    </div><div class="line">    - inPreferredConfig 指定图片格式</div><div class="line">    </div><div class="line">	支持的图片格式</div><div class="line">	</div><div class="line">	 | 格式 | 描述 |</div><div class="line">	 | :---- | :---- |</div><div class="line">     |ALPHA_8|	    只有一个alpha通道</div><div class="line">     |ARGB_4444|	这个从API 13开始已经废弃，因为质量太差</div><div class="line">     |ARGB_8888|	ARGB四个通道，每个通道8bit</div><div class="line">     |RGB_565|	    每个像素占2Byte，其中红色占5bit，绿色占6bit，蓝色占5bit</div><div class="line">    </div><div class="line">    默认会使用ARGB_8888，在这个模式下一个像素点将会占用4个byte，而对一些没有透明度要求或者图片质量要求不高的图片，可以使用RGB_565，一个像素只会占用2个byte，可以省下50%内存。</div><div class="line">	- 使用Ashmem内存</div><div class="line">	</div><div class="line">	Ashmem内存区域是不能被Java应用直接使用的，但这其中有一些例外，而Bitmap是其中一个。</div></pre></td></tr></table></figure>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inPurgeable = true;
options.inInputShareable = true;
Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, options);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    缺点：</div><div class="line">当系统内存不足时回收这个bitmap，如果一个被回收的bitmap在之后又要被使用，系统会重新decode，但是这个decode操作是发生在UI线程中的可能会造成掉帧现象，因此改做法已经被Google废弃掉，推荐使用 inBitmap。</div><div class="line">    - inBitmap</div><div class="line">告知bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的`pixel data`内存区域，而不是去问内存重新申请一块区域来存放bitmap。</div><div class="line">使用`inBitmap`需要注意几个限制条件：</div><div class="line">在`SDK 11 -&gt; 18`之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100x100，那么新申请的bitmap必须也为100x100才能够被重用。从`SDK19`开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。 新申请的bitmap与旧的bitmap必须有相同的解码格式，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。</div><div class="line">    - 使用软引用对bitmap做缓存</div></pre></td></tr></table></figure>
<p>private Map<string, softreference<bitmap="">&gt; imageCache = new HashMap<string, softreference<bitmap="">&gt;();<br>public void addBitmapToCache(String path) {</string,></string,></p>
<pre><code>// 强引用的Bitmap对象
Bitmap bitmap = BitmapFactory.decodeFile(path);
// 软引用的Bitmap对象
SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap);
// 添加该对象到Map中使其缓存
imageCache.put(path, softBitmap);
</code></pre><p>}<br>// 通过SoftReference的get()方法得到Bitmap对象<br>public Bitmap getBitmapByPath(String path) {</p>
<pre><code>// 从缓存中取软引用的Bitmap对象
SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);
if (softBitmap == null) {
    return null;
}
// 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空
Bitmap bitmap = softBitmap.get();
return bitmap;
</code></pre><p>}<br>```</p>
<p>使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免Crash发生。<br>需要注意的是，在垃圾回收器对这个Java对象回收前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该Java对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。</p>
<ul>
<li>图片缓存策略：内存缓存、硬盘缓存等</li>
</ul>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.android.com/topic/performance/memory.html" target="_blank" rel="external">https://developer.android.com/topic/performance/memory.html</a></p>
<p><a href="http://blog.csdn.net/qq_23191031/article/details/63685756" target="_blank" rel="external">Android性能优化详解内存优化的来龙去脉</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578816&amp;idx=1&amp;sn=20b6160e92167dde676561f3a43d0860&amp;chksm=84b3b447b3c43d51c8042b58fef7dcb2755bdb4ceffaf8244b1e88acc6231411e3e9a5f0368f&amp;mpshare=1&amp;scene=24&amp;srcid=0407gek6TWkslG13uVNKgWnp&amp;key=3b2e3b347972bda0160ce87a12f2ac4023e07bae8d2643824f5099d643f67bc11fda267841bc5d474d01ae1bb79b1a07ea270e4f0e22c2a233e564a8f0513fdc8774006a07712f5dd523b4a48d7fb994&amp;ascene=0&amp;uin=MzU5MTI3NQ%3D%3D&amp;devicetype=iMac+MacBookPro11%2C5+OSX+OSX+10.11.6+build(15G1108" target="_blank" rel="external">Android 内存优化总结</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/分享/" rel="tag"># 分享</a>
          
            <a href="/tags/Blog/" rel="tag"># Blog</a>
          
            <a href="/tags/内存优化/" rel="tag"># 内存优化</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
            <div id="wpac-rating"></div>
          </div>
        

        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/20/2017-05-01-Create an Android Library/" rel="next" title="创建 Android 库">
                <i class="fa fa-chevron-left"></i> 创建 Android 库
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/13/2017-05-13-理解Android中的SharedPreferences/" rel="prev" title="理解Android中的SharedPreferences">
                理解Android中的SharedPreferences <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpeg"
               alt="android9527" />
          <p class="site-author-name" itemprop="name">android9527</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/android9527" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android内存优化相关"><span class="nav-number">1.</span> <span class="nav-text">Android内存优化相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java内存分配策略概述"><span class="nav-number">1.1.</span> <span class="nav-text">Java内存分配策略概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM垃圾回收"><span class="nav-number">1.2.</span> <span class="nav-text">JVM垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">1.3.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">android9527</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  
  <script type="text/javascript">
  wpac_init = window.wpac_init || [];
  wpac_init.push({widget: 'Rating', id: ,
    el: 'wpac-rating',
    color: 'fc6423'
  });
  (function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = '//embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
  })();
  </script>


  

  

  

</body>
</html>
